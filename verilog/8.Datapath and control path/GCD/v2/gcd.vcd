$date
	Wed May 10 00:51:18 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module GCD_test $end
$var wire 1 ! sel_in $end
$var wire 1 " sel2 $end
$var wire 1 # sel1 $end
$var wire 1 $ lt $end
$var wire 1 % ldB $end
$var wire 1 & ldA $end
$var wire 1 ' gt $end
$var wire 1 ( eq $end
$var wire 1 ) done $end
$var reg 1 * clk $end
$var reg 16 + data_in [15:0] $end
$var reg 1 , start $end
$scope module CON $end
$var wire 1 * clk $end
$var wire 1 , start $end
$var wire 1 $ lt $end
$var wire 1 ' gt $end
$var wire 1 ( eq $end
$var reg 1 ) done $end
$var reg 1 & ldA $end
$var reg 1 % ldB $end
$var reg 3 - next_state [2:0] $end
$var reg 1 # sel1 $end
$var reg 1 " sel2 $end
$var reg 1 ! sel_in $end
$var reg 3 . state [2:0] $end
$upscope $end
$scope module DP $end
$var wire 1 * clk $end
$var wire 16 / data_in [15:0] $end
$var wire 1 & ldA $end
$var wire 1 % ldB $end
$var wire 1 # sel1 $end
$var wire 1 " sel2 $end
$var wire 1 ! sel_in $end
$var wire 1 $ lt $end
$var wire 1 ' gt $end
$var wire 1 ( eq $end
$var wire 16 0 Y [15:0] $end
$var wire 16 1 X [15:0] $end
$var wire 16 2 Subout [15:0] $end
$var wire 16 3 Bus [15:0] $end
$var wire 16 4 Bout [15:0] $end
$var wire 16 5 Aout [15:0] $end
$scope module A $end
$var wire 1 * clk $end
$var wire 1 & load $end
$var wire 16 6 data_in [15:0] $end
$var reg 16 7 data_out [15:0] $end
$upscope $end
$scope module B $end
$var wire 1 * clk $end
$var wire 1 % load $end
$var wire 16 8 data_in [15:0] $end
$var reg 16 9 data_out [15:0] $end
$upscope $end
$scope module COMP $end
$var wire 16 : data1 [15:0] $end
$var wire 16 ; data2 [15:0] $end
$var wire 1 $ lt $end
$var wire 1 ' gt $end
$var wire 1 ( eq $end
$upscope $end
$scope module MUX_in1 $end
$var wire 16 < in0 [15:0] $end
$var wire 16 = in1 [15:0] $end
$var wire 1 # sel $end
$var wire 16 > out [15:0] $end
$upscope $end
$scope module MUX_in2 $end
$var wire 16 ? in0 [15:0] $end
$var wire 16 @ in1 [15:0] $end
$var wire 1 " sel $end
$var wire 16 A out [15:0] $end
$upscope $end
$scope module MUX_load $end
$var wire 16 B in1 [15:0] $end
$var wire 1 ! sel $end
$var wire 16 C out [15:0] $end
$var wire 16 D in0 [15:0] $end
$upscope $end
$scope module SB $end
$var wire 16 E in1 [15:0] $end
$var wire 16 F in2 [15:0] $end
$var reg 16 G out [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
x,
bx +
0*
x)
x(
x'
x&
x%
x$
x#
x"
x!
$end
#3
1,
#5
1*
#10
0*
#12
b10001111 +
b10001111 /
b10001111 B
#15
1*
#20
0*
#22
b1001110 +
b1001110 /
b1001110 B
#25
1*
#30
0*
#35
1*
#40
0*
#45
1*
#50
0*
#55
1*
#60
0*
#65
1*
#70
0*
#75
1*
#80
0*
#85
1*
#90
0*
#95
1*
#100
0*
#105
1*
#110
0*
#115
1*
#120
0*
#125
1*
#130
0*
#135
1*
#140
0*
#145
1*
#150
0*
#155
1*
#160
0*
#165
1*
#170
0*
#175
1*
#180
0*
#185
1*
#190
0*
#195
1*
#200
0*
#203
